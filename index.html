<!DOCTYPE html>
<html>
<head>
    <title>SilhouetteIllusion</title>
    <style>
        body { margin: 0; }
    </style>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r123/three.min.js"></script> -->
    <!-- <script src="http://gero3.github.io/threejs_STLLoader/three.min.js"></script> -->
    <!-- <script src="https://stemkoski.github.io/Three.js/js/OrbitControls.js"></script> -->
    <!-- <script src="https://stemkoski.github.io/Three.js/js/THREEx.FullScreen.js"></script> -->
    <!-- <script src="https://stemkoski.github.io/Three.js/js/THREEx.WindowResize.js"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <!-- <script src="http://gero3.github.io/threejs_STLLoader/STLLoader2.js"></script> -->
</head>
<body>
<script type="module">

    import * as THREE from './build/three.module.js';

    import { STLLoader } from './examples/jsm/loaders/STLLoader.js';

    let letter_widths = {
        'A':10.3615,
        'B':9.3179,
        'C':10.4161,
        'D':10.0341,
        'E':9.236,
        'F':8.41064,
        'G':11.14598,
        'H':9.99318,
        'I':3.60164,
        'J':7.63302,
        'K':9.31787,
        'L':7.76944,
        'M':11.62347,
        'N':10.04775,
        'O':11.21419,
        'P':9.2633,
        'Q':11.28922,
        'R':10.01364,
        'S':9.71351,
        'T':9.22919,
        'U':10.01364,
        'V':10.27967,
        'W':14.0382,
        'X':10.27967,
        'Y':10.30014,
        'Z':9.27694
    }
    
    function developGrid(word1, word2) {
        let word1_is_longer = word1.length >= word2.length
        let shorter_word = ""
        let longer_word = ""
        if (word1_is_longer) {
            longer_word = word1
            shorter_word = word2
        }
        else {
            longer_word = word2
            shorter_word = word1
        }

        let letter_priority = {
            "A":14,
            "B":16,
            "C":25,
            "D":10,
            "E":11,
            "F":18,
            "G":24,
            "H":4,
            "I":19,
            "J":26,
            "K":6,
            "L":20,
            "M":7,
            "N":12,
            "O":13,
            "P":21,
            "Q":9,
            "R":8,
            "S":22,
            "T":17,
            "U":2,
            "V":3,
            "W":1,
            "X":5,
            "Y":15,
            "Z":23,
            "M":7,
            "N":12,
            "O":13,
            "P":21,
            "Q":9,
            "R":8,
            "S":22,
            "T":17,
            "U":2,
            "V":3,
            "W":1,
            "X":5,
            "Y":15,
            "Z":23,
        }

        // ----- DETERMINE SHORTER MESSAGE SPLITTING -----
        let shorter_word_nums = []
        let longer_word_nums = []

        for (let i=0; i<longer_word.length; i=i+1 ) {
            longer_word_nums[i] = 1
        }

        for (let i=0; i<shorter_word.length; i=i+1 ) {
            shorter_word_nums[i] = 1
        }

        let shorter_word_num_total = shorter_word.length

        while (shorter_word_num_total < longer_word.length) {
            let best_letter = 0
            let lowest_priority = 100
            let lowest_num = 100
        
            for (let i=0; i<shorter_word.length; i=i+1 ) {
                if (shorter_word_nums[i] < lowest_num) {
                    best_letter = i
                    lowest_priority = letter_priority[shorter_word.charAt(i)]
                    lowest_num = shorter_word_nums[i]
                }
                else if (shorter_word_nums[i] == lowest_num && letter_priority[shorter_word.charAt(i)] <= lowest_priority) {
                    best_letter = i
                    lowest_priority = letter_priority[shorter_word.charAt(i)]
                    lowest_num = shorter_word_nums[i]
                }
            }
            shorter_word_nums[best_letter] = shorter_word_nums[best_letter] + 1
            shorter_word_num_total = shorter_word_num_total + 1
        }

        let longer_word_array = []
        let shorter_word_array = []
        let shorter_word_letter_complete = []
        let longer_word_new_letter = []

        for (let i=0; i<longer_word.length; i=i+1 ) {
            longer_word_array.push(longer_word.charAt(i));
            longer_word_new_letter[i] = true;
        }
        
        for (let i=0; i<shorter_word.length; i=i+1 ) {
            if (shorter_word_nums[i] == 1) {
                shorter_word_array.push(shorter_word.charAt(i))
                shorter_word_letter_complete.push(true)
            }
            else {
                for (let j=0; j<shorter_word_nums[i]; j=j+1) {
                    shorter_word_letter_complete.push(j==shorter_word_nums[i]-1)
                    if (j < Math.floor(shorter_word_nums[i]/2)) {
                        shorter_word_array.push(shorter_word.charAt(i)+"l")
                    }
                    else {
                        shorter_word_array.push(shorter_word.charAt(i)+"r")
                    }
                }
            }
        }

        // let longer_word_array = []
        // let shorter_word_array = []
        // let shorter_remaining = shorter_word.length
        // let longer_remaining = longer_word.length
        // for (let i=0; i<shorter_word.length; i=i+1 ) {
        //     let average_remaining = Math.ceil(longer_remaining/shorter_remaining)
        //     if (average_remaining == 1) {
        //         shorter_word_array.push(shorter_word.charAt(shorter_word.length - shorter_remaining))
        //         longer_word_array.push(longer_word.charAt(longer_word.length - longer_remaining))
        //         longer_remaining = longer_remaining - 1
        //         shorter_remaining = shorter_remaining - 1
        //     }
        //     else {
        //         for (let j = 0; j<average_remaining; j = j + 1) {
        //             if (j%2 == 0) {
        //                 shorter_word_array.push(shorter_word.charAt(shorter_word.length - shorter_remaining)+"_left")
        //             }
        //             else {
        //                 shorter_word_array.push(shorter_word.charAt(shorter_word.length - shorter_remaining)+"_right")
        //             }
        //             longer_word_array.push(longer_word.charAt(longer_word.length - longer_remaining))
        //             longer_remaining = longer_remaining - 1
        //         }
        //         shorter_remaining = shorter_remaining - 1
        //     }
        // }
        // console.log(shorter_word_new_letter)
        if (word1_is_longer) {
            // console.log(longer_word_array, shorter_word_array)
            return [longer_word_array, shorter_word_array, longer_word_new_letter, shorter_word_letter_complete]
        }
        else {
            // console.log(shorter_word_array, longer_word_array)
            return [shorter_word_array, longer_word_array, shorter_word_letter_complete, longer_word_new_letter]
        }
    }

    // ---- CREATE GUI -----
    function dummy(){ // example function to execute when GUI button is clicked
        console.log("you're dumb")
    }

    // create color pallete
    const palette = {
        color: '#ffffff',
    }

    // add buttons and parameters to GUI
    const params = {
        message1: "HELLO",
        message2: "WORLD",
        add_base: true,
        create_illusion: dummy,
    };

    const gui = new dat.GUI();
    gui.add(params, 'message1').onChange(
        function(value){
            message1 = value.toUpperCase().replace(/[^A-Z]/gi, ''); // make everything uppercase and weed out non-alphabetic chars
            refreshText();
        }
    )
    gui.add(params, 'message2').onChange(
        function(value){
            message2 = value.toUpperCase().replace(/[^A-Z]/gi, ''); // make everything uppercase and weed out non-alphabetic chars
            refreshText();
        }
    )

    gui.addColor(palette, 'color').onChange(
        function(value){
            color = value;
            refreshText();
        }
    );

    gui.add(params, 'add_base');
    gui.add(params, 'create_illusion');

    // ----- ADD EVENT LISTENERS -----

    window.addEventListener("keypress", function(event) {
        if (!(event.which == 115 && event.ctrlKey) && !(event.which == 19)) return true
        alert("Ctrl-S pressed")
        event.preventDefault()
        return false
    })

    // THREE.Cache.enabled = true;

    let container, stats, permalink, hex;

    let camera, cameraTarget, scene, renderer;

    let group, Mesh1, textMesh2, textGeo, materials, Mesh2, textMesh22, textGeo2, material;
    let message1 = "HELLO",
        message2 = "WORLD",
        color = "#ffffff",
    font = undefined,
        fontName = "optimer", // helvetiker, optimer, gentilis, droid sans, droid serif
        fontWeight = "bold"; // normal bold

    const height = 300,
        size = 50,
        hover = 30,
        curveSegments = 4;

    const fontMap = {

        "helvetiker": 0,
        "optimer": 1,
        "gentilis": 2,
        "droid/droid_sans": 3,
        "droid/droid_serif": 4
    };

    const weightMap = {

        "regular": 0,
        "bold": 1
    };

    const reverseFontMap = [];
    const reverseWeightMap = [];

    for ( const i in fontMap ) reverseFontMap[ fontMap[ i ] ] = i;
    for ( const i in weightMap ) reverseWeightMap[ weightMap[ i ] ] = i;

    let targetRotation = 0;
    let targetRotationOnPointerDown = 0;

    let pointerX = 0;
    let pointerXOnPointerDown = 0;

    let windowHalfX = window.innerWidth / 2;

    let fontIndex = 1;

    init();
    animate();

    function decimalToHex( d ) {

        let hex = Number( d ).toString( 16 );
        hex = "000000".substr( 0, 6 - hex.length ) + hex;
        return hex.toUpperCase();

    }

    function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        // permalink = document.getElementById( "permalink" );

        // CAMERA

        camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 1500 );
        camera.position.set( 0, 10, 20 );

        cameraTarget = new THREE.Vector3( 0, 150, 0 );

        // SCENE

        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0x000000 );
        scene.fog = new THREE.Fog( 0x000000, 250, 1400 );

        // LIGHTS

        const dirLight = new THREE.DirectionalLight( 0xffffff, 0.125 );
        dirLight.position.set( 0, 0, 1 ).normalize();
        scene.add( dirLight );

        const pointLight = new THREE.PointLight( 0xffffff, 1.5 );
        pointLight.position.set( 0, 100, 90 );
        scene.add( pointLight );

        const pointLight2 = new THREE.DirectionalLight( 0xffffff, 1.5 );
        pointLight2.position.set( 100, 100, 90 );
        scene.add( pointLight2 );

        // set colors
        pointLight.color.setHSL(1,1,1);
        pointLight2.color.setHSL(0.5,1,1);
        hex = decimalToHex( pointLight.color.getHex() );

        materials = [
            new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } ), // front
            new THREE.MeshPhongMaterial( { color: 0xffffff } ) // side
        ];

        material = materials[0]

        group = new THREE.Group();
        group.position.y = 100;

        scene.add( group );

        // loadFont();

        // const plane = new THREE.Mesh(
        //     new THREE.PlaneBufferGeometry( 10000, 10000 ),
        //     new THREE.MeshBasicMaterial( { color: 0xffffff, opacity: 0.5, transparent: true } )
        // );

        // plane.position.y = 100;
        // plane.rotation.x = - Math.PI / 2;
        // scene.add( plane );

        // RENDERER

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );
        
        // EVENTS

        container.style.touchAction = 'none';
        container.addEventListener( 'pointerdown', onPointerDown, false );
        window.addEventListener( 'resize', onWindowResize, false );

    }

    function onWindowResize() {

        windowHalfX = window.innerWidth / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function loadFont() {

        // const loader = new THREE.FontLoader();
        // loader.load( 'fonts/' + fontName + '_' + fontWeight + '.typeface.json', function ( response ) {

        //     font = response;

        //     refreshText();

        // } );
    }

    function createTexts() { // CREATE THE FIRST TEXT MESH
        // ----- determine length of mesh 1 -----
        // create a temporary instance of second mesh 2 in order to get the length of mesh 1
        let tempObject = new THREE.TextGeometry( message2, {
            font: font,
            size: size,
            height: 30,
            curveSegments: curveSegments,
        } );

        tempObject.computeBoundingBox(); // compute bounding box of the temp mesh
        let shape1depth = tempObject.boundingBox.max.x - tempObject.boundingBox.min.x; // determine shape1height

        // ------ create mesh 1 -----
        let textGeo = new THREE.TextGeometry( message1, { // CREATE MESH 1
            font: font,
            size: size,
            height: shape1depth,
            curveSegments: curveSegments,
        } );

        textGeo.computeBoundingBox(); // compute bounding box for text mesh
        textGeo.computeVertexNormals(); // compute the center of the mesh (vertex normals)
        
        textGeo = new THREE.BufferGeometry().fromGeometry( textGeo );

        Mesh1 = new THREE.Mesh( textGeo, materials );

        Mesh1.position.x = 0;
        Mesh1.position.y = 0;
        Mesh1.position.z = 0;

        Mesh1.rotation.x = 0;
        Mesh1.rotation.y = 2 * Math.PI;

        Mesh1.updateMatrix();
        Mesh1.geometry = Mesh1.geometry.clone();
        Mesh1.geometry.applyMatrix( Mesh1.matrix );
        Mesh1.matrix.identity();

        Mesh1.position.set(0, 0, 0);
        Mesh1.rotation.set( 0, 0, 0 );
        Mesh1.scale.set( 1, 1, 1 );

        // group.add( Mesh1 );

        // ----- CREATE MESH 2 -----
        let shape2depth = textGeo.boundingBox.max.x - textGeo.boundingBox.min.x;
        console.log(shape2depth);
        textGeo2 = new THREE.TextGeometry( message2, {
            font: font,
            size: size,
            height: shape2depth,
            curveSegments: curveSegments,
        } );

        textGeo2.computeBoundingBox();
        textGeo2.computeVertexNormals();

        textGeo2 = new THREE.BufferGeometry().fromGeometry( textGeo2 );

        Mesh2 = new THREE.Mesh( textGeo2, materials );

        Mesh2.position.x = 0;
        Mesh2.position.y = 0;
        Mesh2.position.z = shape1depth;

        Mesh2.rotation.x = 0;
        Mesh2.rotation.y = 1/2 * Math.PI;

        Mesh2.updateMatrix();
        Mesh2.geometry = Mesh2.geometry.clone();
        Mesh2.geometry.applyMatrix( Mesh2.matrix );
        Mesh2.matrix.identity();

        Mesh2.position.set(0, 0, 0);
        Mesh2.rotation.set( 0, 0, 0 );
        Mesh2.scale.set( 1, 1, 1 );

        let boundingBox1 = new THREE.Box3().setFromObject(Mesh1);
        let boundingBox2 = new THREE.Box3().setFromObject(Mesh2);

        console.log(boundingBox2.min.y, boundingBox1.min.y)
        // group.add( Mesh2 );
    }

    let mesh_list = []

    function refreshText() {
        group.remove(...group.children);
        // group.remove( Mesh1 );
        // group.remove( Mesh2 );
        // createTexts();
        let grid_data = developGrid(message1, message2)
        console.log(grid_data)
        let currentPosition = new THREE.Vector3(0, 0, 0)
        
        for (let i =0; i<grid_data[0].length;i=i+1) {
            let objectFileName = grid_data[0][i] + "_" + grid_data[1][i] + ".stl";
            let moveX = grid_data[2][i]
            let moveZ = grid_data[3][i]
            
            loadObjectAtPosition(objectFileName, currentPosition.clone())
            if (moveX) {
                currentPosition.x = currentPosition.x + letter_widths[grid_data[0][i].charAt(0)]
            }
            if (moveX) {
                currentPosition.z = currentPosition.z - letter_widths[grid_data[1][i].charAt(0)]
            }
        }

    }
    
    function loadObjectAtPosition (fileName, vectorPosition) {
        const loader = new STLLoader();
        
        loader.load( "./models/"+fileName, function ( geometry ) {
            console.log("things", geometry)
            
            // const mesh = new THREE.Mesh( geometry, material );

            // mesh.position.set( 0.136, - 0.37, - 0.6 );
            // mesh.rotation.set( - Math.PI / 2, 0.3, 0 );
            // mesh.scale.set( 2, 2, 2 );

            // mesh.castShadow = true;
            // mesh.receiveShadow = true;

            // scene.add( mesh );
            // let geometry = event.content;
            // var material = new THREE.MeshPhongMaterial( { ambient: 0xff5533, color: 0xff5533, specular: 0x111111, shininess: 200 } );
            console.log("123")
            console.log(fileName, "./models/"+fileName)
            let mesh = new THREE.Mesh( geometry, material );
            console.log("12323")
            mesh.position.set(vectorPosition);

            mesh.castShadow = true;
            mesh.receiveShadow = true;

            group.add(mesh);
            render()

} );

        // loader.addEventListener( 'load', function ( event ) {

        //     let geometry = event.content;
        //     // var material = new THREE.MeshPhongMaterial( { ambient: 0xff5533, color: 0xff5533, specular: 0x111111, shininess: 200 } );
        //     let mesh = new THREE.Mesh( geometry, material );

        //     mesh.position = vectorPosition;

        //     mesh.castShadow = true;
        //     mesh.receiveShadow = true;

        //     group.add(mesh);
        //     render()
        // });

        // loader.load(fileName);

        // var loader = new THREE.STLLoader();
		// 		loader.addEventListener( 'load', function ( event ) {

		// 			var geometry = event.content;
		// 			var mesh = new THREE.Mesh( geometry, material );

		// 			mesh.position.set( 0, - 0.37, - 0.6 );
		// 			mesh.rotation.set( - Math.PI / 2, 0, 0 );
		// 			mesh.scale.set( 2, 2, 2 );

		// 			mesh.castShadow = true;
		// 			mesh.receiveShadow = true;

		// 			scene.add( mesh );

		// 		} );
		// 		loader.load( 'http://corsify.appspot.com/https://raw.github.com/mrdoob/three.js/master/examples/models/stl/binary/pr2_head_pan.stl' );

    }

    function onPointerDown( event ) {

        if ( event.isPrimary === false ) return;

        pointerXOnPointerDown = event.clientX - windowHalfX;
        targetRotationOnPointerDown = targetRotation;

        document.addEventListener( 'pointermove', onPointerMove, false );
        document.addEventListener( 'pointerup', onPointerUp, false );

    }

    function onPointerMove( event ) {

        if ( event.isPrimary === false ) return;

        pointerX = event.clientX - windowHalfX;

        targetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;

    }

    function onPointerUp() {

        if ( event.isPrimary === false ) return;

        document.removeEventListener( 'pointermove', onPointerMove );
        document.removeEventListener( 'pointerup', onPointerUp );

    }

    function animate() {
        requestAnimationFrame( animate );
        render();
    }

    function render() {
        group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05; // This is where the drag happens
        camera.lookAt( cameraTarget );
        renderer.clear();
        renderer.render( scene, camera );
    }
</script>
</body>
</html>