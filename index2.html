<!DOCTYPE html>
<html>
<head>
    <title>SilhouetteIllusion</title>
    <style>
        body { margin: 0; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r123/three.min.js"></script>
    <script src="https://stemkoski.github.io/Three.js/js/Detector.js"></script>
    <script src="https://stemkoski.github.io/Three.js/js/Stats.js"></script>
    <script src="https://stemkoski.github.io/Three.js/js/OrbitControls.js"></script>
    <script src="https://stemkoski.github.io/Three.js/js/THREEx.FullScreen.js"></script>
    <script src="https://stemkoski.github.io/Three.js/js/THREEx.WindowResize.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
</head>
<body>
<script>
    // ---- CREATE GUI -----
    function dummy(){ // example function to execute when GUI button is clicked
        console.log("you're dumb")
    }

    // add buttons and parameters to GUI
    const params = {
        message1: "",
        message2: "",
        unusednum: 0.5,
        unusedbool: true,
        unusedfunct: dummy,
    };

    const gui = new dat.GUI();
    gui.add(params, 'message1').onChange(function(value){message1 = value; refreshText()})
    gui.add(params, 'message2').onChange(function(value){message2 = value; refreshText()})
    gui.add(params, 'unusednum', 0, 1).step(0.01).onChange(function(value) {} );
    gui.add(params, 'unusedbool')
    gui.add(params, 'unusedfunct')

    // ----- END GUI -----

    window.addEventListener("keypress", function(event) {
        if (!(event.which == 115 && event.ctrlKey) && !(event.which == 19)) return true
        alert("Ctrl-S pressed")
        event.preventDefault()
        return false
    })

    THREE.Cache.enabled = true;

    let container, stats, permalink, hex;

    let camera, cameraTarget, scene, renderer;

    let group, textMesh1, textMesh2, textGeo, materials, textMesh12, textMesh22, textGeo2;
    let message1 = "HELLO",
        message2 = "WORLD",
        bevelEnabled = true,
        font = undefined,
        fontName = "optimer", // helvetiker, optimer, gentilis, droid sans, droid serif
        fontWeight = "bold"; // normal bold

    const height = 300,
        size = 50,
        hover = 30,
        curveSegments = 4,
        bevelThickness = 2,
        bevelSize = 1.5;

    const fontMap = {

        "helvetiker": 0,
        "optimer": 1,
        "gentilis": 2,
        "droid/droid_sans": 3,
        "droid/droid_serif": 4
    };

    const weightMap = {

        "regular": 0,
        "bold": 1
    };

    const reverseFontMap = [];
    const reverseWeightMap = [];

    for ( const i in fontMap ) reverseFontMap[ fontMap[ i ] ] = i;
    for ( const i in weightMap ) reverseWeightMap[ weightMap[ i ] ] = i;

    let targetRotation = 0;
    let targetRotationOnPointerDown = 0;

    let pointerX = 0;
    let pointerXOnPointerDown = 0;

    let windowHalfX = window.innerWidth / 2;

    let fontIndex = 1;

    init();
    animate();

    function decimalToHex( d ) {

        let hex = Number( d ).toString( 16 );
        hex = "000000".substr( 0, 6 - hex.length ) + hex;
        return hex.toUpperCase();

    }

    function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        // permalink = document.getElementById( "permalink" );

        // CAMERA

        camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 1500 );
        camera.position.set( 0, 400, 1000 );

        cameraTarget = new THREE.Vector3( 0, 150, 0 );

        // SCENE

        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0x000000 );
        scene.fog = new THREE.Fog( 0x000000, 250, 1400 );

        // LIGHTS

        const dirLight = new THREE.DirectionalLight( 0xffffff, 0.125 );
        dirLight.position.set( 0, 0, 1 ).normalize();
        scene.add( dirLight );

        const pointLight = new THREE.PointLight( 0xffffff, 1.5 );
        pointLight.position.set( 0, 100, 90 );
        scene.add( pointLight );

        const pointLight2 = new THREE.DirectionalLight( 0xffffff, 1.5 );
        pointLight2.position.set( 100, 100, 90 );
        scene.add( pointLight2 );

        // set colors
        pointLight.color.setHSL( Math.random(), 1, 0.5 );
        pointLight2.color.setHSL( Math.random(), 1, 0.5 );
        hex = decimalToHex( pointLight.color.getHex() );

        materials = [
            new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } ), // front
            new THREE.MeshPhongMaterial( { color: 0xffffff } ) // side
        ];

        group = new THREE.Group();
        group.position.y = 100;

        scene.add( group );

        loadFont();

        const plane = new THREE.Mesh(
            new THREE.PlaneBufferGeometry( 10000, 10000 ),
            new THREE.MeshBasicMaterial( { color: 0xffffff, opacity: 0.5, transparent: true } )
        );

        plane.position.y = 100;
        plane.rotation.x = - Math.PI / 2;
        scene.add( plane );

        // RENDERER

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        // STATS

        // stats = new Stats();
        //container.appendChild( stats.dom );

        // EVENTS

        container.style.touchAction = 'none';
        container.addEventListener( 'pointerdown', onPointerDown, false );
        window.addEventListener( 'resize', onWindowResize, false );

    }

    function onWindowResize() {

        windowHalfX = window.innerWidth / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    //

    function boolToNum( b ) {

        return b ? 1 : 0;

    }

    function loadFont() {

        const loader = new THREE.FontLoader();
        loader.load( 'fonts/' + fontName + '_' + fontWeight + '.typeface.json', function ( response ) {

            font = response;

            refreshText();

        } );
    }

    function createText() { // CREATE THE FIRST TEXT MESH
        // ----- determine length of mesh 1 -----
        // create a temporary instance of second mesh 2 in order to get the length of mesh 1
        let tempObject = new THREE.TextGeometry( message2, {

            font: font,

            size: size,
            height: 30,
            curveSegments: curveSegments,

            bevelThickness: bevelThickness,
            bevelSize: bevelSize,
            bevelEnabled: bevelEnabled
        } );

        tempObject.computeBoundingBox(); // compute bounding box of the temp mesh
        let shape1Height = tempObject.boundingBox.max.x - tempObject.boundingBox.min.x; // determine shape1height

        // ------ create mesh 1 -----
        let textGeo = new THREE.TextGeometry( message1, { // CREATE MESH 1

            font: font,

            size: size,
            height: shape1Height,
            curveSegments: curveSegments,

            bevelThickness: bevelThickness,
            bevelSize: bevelSize,
            bevelEnabled: bevelEnabled

        } );

        textGeo.computeBoundingBox(); // compute bounding box for text mesh
        textGeo.computeVertexNormals(); // compute the center of the mesh (vertex normals)

        // ----- WEIRD BEVEL SHIT I DONT UNDERSTAND -----
        const triangle = new THREE.Triangle();

        // "fix" side normals by removing z-component of normals for side faces
        // (this doesn't work well for beveled geometry as then we lose nice curvature around z-axis)

        if ( ! bevelEnabled ) {

            const triangleAreaHeuristics = 0.1 * ( height * size );

            for ( let i = 0; i < textGeo.faces.length; i ++ ) {

                const face = textGeo.faces[ i ];

                if ( face.materialIndex == 1 ) {

                    for ( let j = 0; j < face.vertexNormals.length; j ++ ) {

                        face.vertexNormals[ j ].z = 0;
                        face.vertexNormals[ j ].normalize();

                    }

                    const va = textGeo.vertices[ face.a ];
                    const vb = textGeo.vertices[ face.b ];
                    const vc = textGeo.vertices[ face.c ];

                    const s = triangle.set( va, vb, vc ).getArea();

                    if ( s > triangleAreaHeuristics ) {

                        for ( let j = 0; j < face.vertexNormals.length; j ++ ) {

                            face.vertexNormals[ j ].copy( face.normal );

                        }
                    }
                }
            }
        }

        const centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x ); // rotation axis at center of message

        textGeo = new THREE.BufferGeometry().fromGeometry( textGeo );

        textMesh1 = new THREE.Mesh( textGeo, materials );

        textMesh1.position.x = centerOffset;
        textMesh1.position.y = hover;
        textMesh1.position.z = 0;

        textMesh1.rotation.x = 0;
        textMesh1.rotation.y = Math.PI * 2;

        textMesh1.updateMatrix();
        textMesh1.geometry = textMesh1.geometry.clone();
        textMesh1.geometry.applyMatrix( textMesh1.matrix );
        textMesh1.matrix.identity();

        textMesh1.position.set(0, 0, 0);
        textMesh1.rotation.set( 0, 0, 0 );
        textMesh1.scale.set( 1, 1, 1 );

        group.add( textMesh1 );
    }

    function createText2(array, offset) { // CREATE THE SECOND TEXT MESH
        let tempObject = new THREE.TextGeometry( message1, {
            font: font,

            size: size,
            height: 50,
            curveSegments: curveSegments,

            bevelThickness: bevelThickness,
            bevelSize: bevelSize,
            bevelEnabled: bevelEnabled

        } );
        tempObject.computeBoundingBox();
        let shape2Height = tempObject.boundingBox.max.x - tempObject.boundingBox.min.x;
        console.log(shape2Height);
        textGeo2 = new THREE.TextGeometry( message2, {

            font: font,

            size: size,
            height: shape2Height,
            curveSegments: curveSegments,

            bevelThickness: bevelThickness,
            bevelSize: bevelSize,
            bevelEnabled: bevelEnabled

        } );

        textGeo2.computeBoundingBox();
        textGeo2.computeVertexNormals();

        const triangle = new THREE.Triangle();

        // "fix" side normals by removing z-component of normals for side faces
        // (this doesn't work well for beveled geometry as then we lose nice curvature around z-axis)

        if ( ! bevelEnabled ) {

            const triangleAreaHeuristics = 0.1 * ( height * size );

            for ( let i = 0; i < textGeo2.faces.length; i ++ ) {

                const face = textGeo2.faces[ i ];

                if ( face.materialIndex == 1 ) {

                    for ( let j = 0; j < face.vertexNormals.length; j ++ ) {

                        face.vertexNormals[ j ].z = 0;
                        face.vertexNormals[ j ].normalize();

                    }

                    const va = textGeo2.vertices[ face.a ];
                    const vb = textGeo2.vertices[ face.b ];
                    const vc = textGeo2.vertices[ face.c ];

                    const s = triangle.set( va, vb, vc ).getArea();

                    if ( s > triangleAreaHeuristics ) {

                        for ( let j = 0; j < face.vertexNormals.length; j ++ ) {

                            face.vertexNormals[ j ].copy( face.normal );

                        }

                    }

                }

            }

        }

        const centerOffset = - 0.5 * ( textGeo2.boundingBox.max.x - textGeo2.boundingBox.min.x );

        textGeo2 = new THREE.BufferGeometry().fromGeometry( textGeo2 );

        textMesh12 = new THREE.Mesh( textGeo2, materials );

        textMesh12.position.x = centerOffset;
        textMesh12.position.y = hover;
        textMesh12.position.z = 0 - 50;

        textMesh12.rotation.x = 0;
        textMesh12.rotation.y = Math.PI/2;

        textMesh12.updateMatrix();
        textMesh12.geometry = textMesh12.geometry.clone();
        textMesh12.geometry.applyMatrix( textMesh12.matrix );
        textMesh12.matrix.identity();

        textMesh12.position.set(0, 0, 0);
        textMesh12.rotation.set( 0, 0, 0 );
        textMesh12.scale.set( 1, 1, 1 );



        let boundingBox1 = new THREE.Box3().setFromObject(textMesh1);
        let boundingBox2 = new THREE.Box3().setFromObject(textMesh12);

        console.log(boundingBox2.min.y, boundingBox1.min.y)

        textMesh12.position.x -= (boundingBox2.max.x - boundingBox1.max.x)
        textMesh12.position.z -= (boundingBox2.max.z - boundingBox1.max.z)
        textMesh12.position.y -= 0

        group.add( textMesh12 );

    }

    function refreshText() {
        group.remove( textMesh1 );
        group.remove( textMesh12 );

        createText();
        createText2();
    }

    function onPointerDown( event ) {

        if ( event.isPrimary === false ) return;

        pointerXOnPointerDown = event.clientX - windowHalfX;
        targetRotationOnPointerDown = targetRotation;

        document.addEventListener( 'pointermove', onPointerMove, false );
        document.addEventListener( 'pointerup', onPointerUp, false );

    }

    function onPointerMove( event ) {

        if ( event.isPrimary === false ) return;

        pointerX = event.clientX - windowHalfX;

        targetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;

    }

    function onPointerUp() {

        if ( event.isPrimary === false ) return;

        document.removeEventListener( 'pointermove', onPointerMove );
        document.removeEventListener( 'pointerup', onPointerUp );

    }

    function animate() {
        requestAnimationFrame( animate );
        render();
    }

    function render() {
        group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
        camera.lookAt( cameraTarget );
        renderer.clear();
        renderer.render( scene, camera );
    }
</script>
</body>
</html>